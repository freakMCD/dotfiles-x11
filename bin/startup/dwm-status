#!/bin/bash
#

# INIT
printf "$$" > ~/.cache/pidofbar
sec=0

# Colors
white=#c8d3d5
cyan=#65b3d5
green=#25b325
red=#E42217
grey=#888888
darkgrey=#121212

update_network () {
    checknet=$(nslookup google.com >&/dev/null; echo $?)

    if [ $checknet -eq 0 ]; then
		network=" ^c$green^󰈀 up"
    else 
		network=" ^c$red^󰈀 down "
	fi
}

update_cpu () { 
    cpu="^c$white^^b$darkgrey^ CPU $(grep -o "^[^ ]*" /proc/loadavg) ^d^"
}

update_memory () { 
    mem="^c$cyan^󰍛 ^c$white^$(awk '/MemT/ {t=$2/1000**2} /^(MemF|Bu|Ca)/ {f+=$2/1000**2} END {printf "%.1fG^c'"$grey"'^/%dG",t-f,t}' /proc/meminfo)"
}

update_disk () {
    disk="^c$cyan^  ^c$white^$(df -Ph | grep "/dev/sda3" | awk {'print $5'})"
}

update_time () { 
    time="^c$cyan^  ^c$white^$(date "+%a-%d-%b ^b$darkgrey^  %R")" 
}

# modules that don't update on their own
# they are also run at the start for getting the initial value
update_vol () { 
    vol="$([ "$(pactl get-sink-mute @DEFAULT_SINK@ | awk '{print $2}')" = "no" ] && printf "^c$cyan^󰕾^d^^f2^" || printf "^c$red^󰝟^f2^") $(pactl get-sink-volume 0 | awk '{print $5}')"
}
update_vol

update_song () {
    if [[ $(mpc status %state%) == 'playing' ]]; then
        song="^c$cyan^ ^c$white^ $(mpc current)"
    elif [[ $(mpc status %state%) == 'paused' ]]; then
        song="^c$grey^  $(mpc current)^d^" 
    else 
        song="fail"
    fi
}

display () {
    xprop -root -set WM_NAME "$song     $vol $cpu $network $mem $disk $time "
}

# signals for each module to update while updating display. RTMIN is 33
trap "update_vol;display" "RTMIN"
trap "update_song;display" "RTMIN+1"

while true; do
	    # how many seconds each module updates
        [ $((sec % 5)) -eq 0 ] && update_network
	    [ $((sec % 5)) -eq 0 ] && update_memory
	    [ $((sec % 15)) -eq 0 ] && update_cpu 
	    [ $((sec % 60 )) -eq 0 ] && update_time
	    [ $((sec % 1800)) -eq 0 ] && update_disk
	    
	    # how often the display updates
	    [ $((sec % 5 )) -eq 0 ] && display
	    sleep 1 & wait && sec=$((sec + 1))
done


