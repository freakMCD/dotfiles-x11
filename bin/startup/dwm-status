#!/bin/bash

# INIT
printf "$$" > ~/.cache/pidofbar

check=1
sec=0

# Colors
green=^c#a9b665^
grey=^c#7c6f64^
red=^c#ea6962^
orange=^c#e78a4e^
yellow=^c#d8a657^
purple=^c#d3869b^

update_network () {
    checknet=$(nslookup google.com >&/dev/null; printf $?)

    if [ $checknet -eq 0 ]; then
		network=" ${green}󰈀 up"
        if [ $check -eq 1 ]; then
            notify-send "Network" "Connected"
            check=0
        fi
    else 
		network=" ${red}󰈀 down"
        if [ $check -eq 0 ]; then
            notify-send "Network" "Disconnected"
            check=1
        fi
	fi
    network="$network^d^"
}

update_cpu () {
    read -r cpu x </proc/loadavg
    cpu="${yellow} CPU^d^ $cpu"
}

update_memory () { 
    mem="${yellow} 󰍛 ^d^$(awk '/MemT/ {t=$2/1000**2} /^(MemF|Bu|Ca)/ {f+=$2/1000**2} END {printf "%.1fG'"${orange}"'/%dG",t-f,t}' /proc/meminfo)^d^"
}

update_disk () {
    disk="${yellow}  ^d^$(df -Ph | grep "/dev/sda3" | awk {'print $5'})"
}

update_time() { 
    time="$(date '+%b %d (%a) %R')"
}

# modules that don't update on their own
# they are also run at the start for getting the initial value
update_vol() { 
    icon="$( [[ $(pactl get-sink-mute @DEFAULT_SINK@ | awk '{printf $2}') == "no" ]] && printf "${yellow}󰕾" || printf "${red}󰝟")"
    value="$(pactl get-sink-volume 0 | awk '{printf $5}')"
    vol=" $icon^f2^^d^ $value"
}
update_vol

update_song () {
    if [[ $(mpc status %state%) == 'playing' ]]; then
        song="${purple}  $(mpc current) ^d^"
    elif [[ $(mpc status %state%) == 'paused' ]]; then
        song="${grey} $(mpc current) ^d^" 
    else 
        song="fail"
    fi
}

display () {
    xprop -root -set WM_NAME "$song    $network  $vol  $cpu  $mem  $disk   ~ $time "
}

# signals for each module to update while updating display. RTMIN is 33
trap "update_vol;display" "RTMIN"
trap "update_song;display" "RTMIN+1"

while true; do
	    # how many seconds each module updates
        [ $((sec % 5)) -eq 0 ] && update_network
	    [ $((sec % 5)) -eq 0 ] && update_memory
	    [ $((sec % 15)) -eq 0 ] && update_cpu 
	    [ $((sec % 60 )) -eq 0 ] && update_time
	    [ $((sec % 1800)) -eq 0 ] && update_disk
	    
	    # how often the display updates
	    [ $((sec % 5 )) -eq 0 ] && display
	    sleep 1 & wait && sec=$((sec + 1))
done


